from typing import List

import numpy as np
from numba import jit


@jit(nopython=True)
def shannon_entropy(input_column: np.ndarray, alpha, lam, m, n) -> float:
    """
    Implementation of the Shannon Entropy for one column formula on page 12 of the paper
    :param input_column: a numpy array in the form of a column generated by FUSINTER
    :param alpha: a scalar weight parameter (see the paper)
    :param lam: a scalar weight parameter (see the paper)
    :m: the number of classes
    :n: sum of all components of the table where column is from
    :return: a scalar value for estimation splits
    """
    col_sum = 0
    n_j = np.sum(input_column)
    col_fac = alpha * n_j / n
    for i in range(m):
        p = (input_column[i] + lam) / (n_j + m * lam)
        col_sum += -(p * np.log2(p))
    result = col_fac * col_sum + (1 - alpha) * m * lam / n_j

    return result


class SplitValueComputer:
    pass


class MaxHeap:
    def __init__(self):
        self.array: List[MaxHeapElement] = []

    def __len__(self):
        return len(self.array)

    def get_parent(self, pos_idx: int):
        assert pos_idx >= 0

        if pos_idx == 0:
            return None
        if pos_idx % 2 == 0:
            return (pos_idx - 1) // 2
        else:
            return pos_idx // 2

    def get_left_child(self, pos):
        return 2 * pos + 1

    def insert(self, table_colum: np.ndarray, prev_idx: int, split_point: float, split_value: float):
        newel = MaxHeapElement(table_colum, prev_idx, -1, split_point, split_value)

        self.array.append(newel)
        pos = len(self.array) - 1

        if prev_idx >= 0:
            self.array[prev_idx].next_idx = pos

        while True:
            parent_pos = self.get_parent(pos)
            if parent_pos is None:
                break

            if self.array[parent_pos].split_value < newel.split_value:
                pos = self.swap(pos)
            else:
                break

        return pos

        # if self.array[parent_pos].split_value < newel.split_value:
        #     parent = self.array[parent_pos]
        #
        #     if newel.prev_idx == parent_pos:
        #         newel.prev_idx, parent.next_idx = parent.next_idx, newel.prev_idx
        #     elif newel.next_idx == parent_pos:
        #         newel.next_idx, parent.prev_idx = parent.prev_idx, newel.next_idx
        #
        #     else:
        #
        #         if parent.prev_idx >= 0:
        #             self.array[parent.prev_idx].next_idx = pos
        #         if parent.next_idx >= 0:
        #             self.array[parent.next_idx].prev_idx = pos
        #
        #         if newel.prev_idx >= 0:
        #             self.array[newel.prev_idx].next_idx = parent_pos
        #         if newel.next_idx >= 0:
        #             self.array[newel.next_idx].prev_idx = parent_pos
        #
        #     self.array[parent_pos], self.array[pos] = self.array[pos], self.array[parent_pos]

    def swap(self, pos):
        assert len(self.array) > pos >= 0
        parent_pos = self.get_parent(pos)

        if parent_pos is None:
            raise ValueError("given pos is already root of heap")

        child = self.array[pos]

        parent = self.array[parent_pos]

        if child.prev_idx == parent_pos:
            child.prev_idx, parent.next_idx = parent.next_idx, child.prev_idx
        elif child.next_idx == parent_pos:
            child.next_idx, parent.prev_idx = parent.prev_idx, child.next_idx

        else:

            if parent.prev_idx >= 0:
                self.array[parent.prev_idx].next_idx = pos
            if parent.next_idx >= 0:
                self.array[parent.next_idx].prev_idx = pos

            if child.prev_idx >= 0:
                self.array[child.prev_idx].next_idx = parent_pos
            if child.next_idx >= 0:
                self.array[child.next_idx].prev_idx = parent_pos

        self.array[parent_pos], self.array[pos] = self.array[pos], self.array[parent_pos]

        return parent_pos

    def heapify(self, pos):
        assert pos < len(self.array)
        if self.get_left_child(pos) >= len(self.array):
            return

        split_value = self.array[pos].split_value
        left_child_idx = self.get_left_child(pos)
        right_child_idx = left_child_idx + 1

        if len(self.array) > right_child_idx:
            if self.array[left_child_idx].split_value < self.array[right_child_idx].split_value:
                max_child_idx = right_child_idx
            else:
                max_child_idx = left_child_idx

        else:
            max_child_idx = left_child_idx

        if self.array[max_child_idx].split_value > self.array[pos].split_value:
            self.swap(max_child_idx)
            self.heapify(max_child_idx)

    def delete(self, pos):
        assert 0 <= pos < len(self.array)
        if pos == len(self.array) - 1:
            to_insert = self.array[-1]
            if to_insert.prev_idx != -1:
                self.array[to_insert.prev_idx].next_idx = -1
            self.array = self.array[:-1]
            return

        to_insert = self.array[-1]
        to_delete = self.array[pos]
        if to_delete.prev_idx != -1:
            self.array[to_delete.prev_idx].next_idx = to_delete.next_idx
        if to_delete.next_idx != -1:
            self.array[to_delete.next_idx].prev_idx = to_delete.prev_idx

        if to_insert.prev_idx != -1:
            self.array[to_insert.prev_idx].next_idx = -1

        self.array[pos] = to_insert
        self.array = self.array[:-1]
        self.heapify(pos)


class MaxHeapElement:
    def __init__(self, table_colum: np.ndarray, prev_idx: int, next_idx: int, split_point: float, split_value: float):
        assert table_colum.ndim == 1
        self.table_column = table_colum
        self.prev_idx = prev_idx
        self.next_idx = next_idx
        self.split_point = split_point
        self.split_value = split_value

    def __repr__(self):
        return f"<MaxHeapElement: {self.table_column}, {self.prev_idx}, {self.next_idx},{self.split_point}, {self.split_value}>"
