import numpy as np


def shannon_entropy(input_column: np.ndarray, alpha, lam, m, n) -> float:
    """
    Implementation of the Shannon Entropy formula on page 12 of the paper
    :param input_table: a numpy array in the form of a table generated by FUSINTER
    :param alpha: a scalar weight parameter (see the paper)
    :param lam: a scalar weight parameter (see the paper)
    :return: a scalar value for estimation splits
    """
    col_sum = 0
    n_j = np.sum(input_column)
    col_fac = alpha * n_j / n
    for i in range(m):
        p = (input_column[i] + lam) / (n_j + m * lam)
        col_sum += -(p * np.log2(p))
    result = col_fac * col_sum + (1 - alpha) * m * lam / n_j

    return result


class MergeValueComputer:
    def __init__(self, input_table, alpha, lam, entropy_func=shannon_entropy):
        self.table = input_table
        self.alpha = alpha
        self.lam = lam

        print(input_table.shape)
        self.m = input_table.shape[0]
        self.k = input_table.shape[1]
        self.n = np.sum(input_table)
        self.entropy_func = lambda x: entropy_func(x, self.alpha, self.lam, self.m, self.n)
        self.cols_entropy = np.apply_along_axis(self.entropy_func, 0, self.table)

    def get_table_entropy(self):
        return np.sum(self.cols_entropy)

    def get_merged_table_entropy(self, col_index):
        entropy = self.get_table_entropy()
        entropy -= self.cols_entropy[col_index]
        entropy -= self.cols_entropy[col_index + 1]
        entropy += self.entropy_func(np.sum(self.table[:, col_index:col_index+2], axis=1))
        return entropy

    def get_all_merge_values(self):
        merge_values = np.zeros(self.k - 1)
        for i in range(self.k - 1):
            merge_values[i] = self.get_merged_table_entropy(i)

        return merge_values